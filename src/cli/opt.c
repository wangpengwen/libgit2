/*
 * Copyright (c), Edward Thomson <ethomson@edwardthomson.com>
 * All rights reserved.
 *
 * This file is part of adopt, distributed under the MIT license.
 * For full terms and conditions, see the included LICENSE file.
 *
 * THIS FILE IS AUTOMATICALLY GENERATED; DO NOT EDIT.
 *
 * This file was produced by using the `rename.pl` script included with
 * adopt.  The command-line specified was:
 *
 * ./rename.pl cli_opt --filename=opt --include=cli.h --inline=GIT_INLINE --header-guard=CLI_opt_h__ --without-usage --lowercase-status
 */

#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <assert.h>

#include "cli.h"
#include "opt.h"

#ifdef _WIN32
# include <Windows.h>
#else
# include <fcntl.h>
# include <sys/ioctl.h>
#endif

#define spec_is_named_type(x) \
	((x)->type == CLI_OPT_BOOL || \
	 (x)->type == CLI_OPT_SWITCH || \
	 (x)->type == CLI_OPT_VALUE || \
	 (x)->type == CLI_OPT_VALUE_OPTIONAL)

GIT_INLINE(const cli_opt_spec *) spec_byname(
	cli_opt_parser *parser, const char *name, size_t namelen)
{
	const cli_opt_spec *spec;

	for (spec = parser->specs; spec->type; ++spec) {
		if (spec->type == CLI_OPT_LITERAL && namelen == 0)
			return spec;

		if (spec_is_named_type(spec) &&
			spec->name &&
			strlen(spec->name) == namelen &&
			strncmp(name, spec->name, namelen) == 0)
			return spec;
	}

	return NULL;
}

GIT_INLINE(const cli_opt_spec *) spec_byalias(cli_opt_parser *parser, char alias)
{
	const cli_opt_spec *spec;

	for (spec = parser->specs; spec->type; ++spec) {
		if (spec_is_named_type(spec) && alias == spec->alias)
			return spec;
	}

	return NULL;
}

GIT_INLINE(const cli_opt_spec *) spec_nextarg(cli_opt_parser *parser)
{
	const cli_opt_spec *spec;
	size_t args = 0;

	for (spec = parser->specs; spec->type; ++spec) {
		if (spec->type == CLI_OPT_ARG) {
			if (args == parser->arg_idx) {
				parser->arg_idx++;
				return spec;
			}

			args++;
		}

		if (spec->type == CLI_OPT_ARGS && args == parser->arg_idx)
			return spec;
	}

	return NULL;
}

static cli_opt_status_t parse_long(cli_opt *opt, cli_opt_parser *parser)
{
	const cli_opt_spec *spec;
	char *arg = parser->args[parser->idx++], *name = arg + 2, *eql;
	size_t namelen;

	namelen = (eql = strrchr(arg, '=')) ? (size_t)(eql - name) : strlen(name);

	opt->arg = arg;

	if ((spec = spec_byname(parser, name, namelen)) == NULL) {
		opt->spec = NULL;
		opt->status = CLI_OPT_STATUS_UNKNOWN_OPTION;
		goto done;
	}

	opt->spec = spec;

	/* Future options parsed as literal */
	if (spec->type == CLI_OPT_LITERAL)
		parser->in_literal = 1;

	if (spec->type == CLI_OPT_BOOL && spec->value)
		*((int *)spec->value) = 1;

	if (spec->type == CLI_OPT_SWITCH && spec->value)
		*((int *)spec->value) = spec->switch_value;

	/* Parse values as "--foo=bar" or "--foo bar" */
	if (spec->type == CLI_OPT_VALUE || spec->type == CLI_OPT_VALUE_OPTIONAL) {
		if (eql && *(eql+1))
			opt->value = eql + 1;
		else if ((parser->idx + 1) <= parser->args_len)
			opt->value = parser->args[parser->idx++];

		if (spec->value)
			*((char **)spec->value) = opt->value;
	}

	/* Required argument was not provided */
	if (spec->type == CLI_OPT_VALUE && !opt->value)
		opt->status = CLI_OPT_STATUS_MISSING_VALUE;
	else
		opt->status = CLI_OPT_STATUS_OK;

done:
	return opt->status;
}

static cli_opt_status_t parse_short(cli_opt *opt, cli_opt_parser *parser)
{
	const cli_opt_spec *spec;
	char *arg = parser->args[parser->idx++], alias = *(arg + 1);

	opt->arg = arg;

	if ((spec = spec_byalias(parser, alias)) == NULL) {
		opt->spec = NULL;
		opt->status = CLI_OPT_STATUS_UNKNOWN_OPTION;
		goto done;
	}

	opt->spec = spec;

	if (spec->type == CLI_OPT_BOOL && spec->value)
		*((int *)spec->value) = 1;

	if (spec->type == CLI_OPT_SWITCH && spec->value)
		*((int *)spec->value) = spec->switch_value;

	/* Parse values as "-ifoo" or "-i foo" */
	if (spec->type == CLI_OPT_VALUE || spec->type == CLI_OPT_VALUE_OPTIONAL) {
		if (strlen(arg) > 2)
			opt->value = arg + 2;
		else if ((parser->idx + 1) <= parser->args_len)
			opt->value = parser->args[parser->idx++];

		if (spec->value)
			*((char **)spec->value) = opt->value;
	}

	/* Required argument was not provided */
	if (spec->type == CLI_OPT_VALUE && !opt->value)
		opt->status = CLI_OPT_STATUS_MISSING_VALUE;
	else
		opt->status = CLI_OPT_STATUS_OK;

done:
	return opt->status;
}

static cli_opt_status_t parse_arg(cli_opt *opt, cli_opt_parser *parser)
{
	const cli_opt_spec *spec = spec_nextarg(parser);

	opt->spec = spec;
	opt->arg = parser->args[parser->idx++];

	if (spec && spec->value)
		*((char **)spec->value) = opt->arg;

	opt->status = spec ? CLI_OPT_STATUS_OK : CLI_OPT_STATUS_UNKNOWN_OPTION;
	return opt->status;
}

void cli_opt_parser_init(
	cli_opt_parser *parser,
	const cli_opt_spec specs[],
	char **args,
	size_t args_len)
{
	assert(parser);

	memset(parser, 0x0, sizeof(cli_opt_parser));

	parser->specs = specs;
	parser->args = args;
	parser->args_len = args_len;
}

cli_opt_status_t cli_opt_parser_next(cli_opt *opt, cli_opt_parser *parser)
{
	assert(opt && parser);

	memset(opt, 0x0, sizeof(cli_opt));

	if (parser->idx >= parser->args_len)
		return CLI_OPT_STATUS_DONE;

	/* Handle arguments in long form, those beginning with "--" */
	if (strncmp(parser->args[parser->idx], "--", 2) == 0 &&
		!parser->in_literal)
		return parse_long(opt, parser);

	/* Handle arguments in short form, those beginning with "-" */
	else if (strncmp(parser->args[parser->idx], "-", 1) == 0 &&
		!parser->in_literal)
		return parse_short(opt, parser);

	/* Handle "free" arguments, those without a dash */
	else
		return parse_arg(opt, parser);
}

cli_opt_status_t cli_opt_parse(
	cli_opt *opt,
	const cli_opt_spec specs[],
	char **args,
	size_t args_len)
{
	cli_opt_parser parser;

	cli_opt_parser_init(&parser, specs, args, args_len);

	while (cli_opt_parser_next(opt, &parser)) {
		if (opt->status != CLI_OPT_STATUS_OK &&
		    opt->status != CLI_OPT_STATUS_DONE) {
			break;
		}
	}

	return opt->status;
}

int cli_opt_status_fprint(
	FILE *file,
	const cli_opt *opt)
{
	int error;

	switch (opt->status) {
	case CLI_OPT_STATUS_DONE:
		error = fprintf(file, "finished processing arguments (no error)\n");
		break;
	case CLI_OPT_STATUS_OK:
		error = fprintf(file, "no error\n");
		break;
	case CLI_OPT_STATUS_UNKNOWN_OPTION:
		error = fprintf(file, "unknown option: %s\n", opt->arg);
		break;
	case CLI_OPT_STATUS_MISSING_VALUE:
		if (strncmp(opt->arg, "--", 2) == 0)
			error = fprintf(file, "option '%s' requires a value.\n",
				opt->spec->name);
		else
			error = fprintf(file, "switch '%c' requires a value.\n",
				opt->spec->alias);
		break;
	default:
		error = fprintf(file, "unknown status: %d\n", opt->status);
		break;
	}

	return error;
}

